если переменая была обьявлена внутри функции main(), компьютер поместит её в область паммяти под названием "стек"
если обьявление произошло вне всяких функций, будет использована глобальная область

& оператор для получения адресса:
присвоить значение
int x = 4;
printf("x находится по адресу %p\n", &x);
coхранить адресс переменной(тип обязательно)
int *address_of_x = &x;
* служит для считывания значения (4)
int value_stored = *address_of_x;

изменить содержимое, хранящеуся по адресу:
*address_of_x = 99;
-------------------------------------------
в 32-битных ос указатель занимает в памяти 4 байта, в 64-битных - 8 байтов
==========================================
sizeof() оператор сколько байтов что-то занимает в паммяти
  sizeof(int) - 4
  sizeof("Черепахи!") - 10
-----------------------------------------------------
передача строки в качестве оргумента
void some_func(char str[])...
при этом в памяти будет храниться ссылка на первый символ
-----------------------------------------------------
переменные массивов и указатели не одно и тоже

char s[] = "Насколько он большой?";
char *t = s;

sizeof(s) вернет сколько массив занимает в памяти
sizeof(t) вернет 4 или 8
&s == s адрес массива
&t !=t адрес переменной

Каждый раз, когда массив передается в функцию, он распадается до указателя
======================================
Переменную массива можно исползовать в качестве указателя на его первый элемент, либо мспользуя квадратные скобки, либо оператор *

int drinks[] = {4,2,3};
printf("1-й заказ: %i напитка\n", drinks[0]);
printf("1-й заказ: %i напитка\n", *drinks);
здесь drinks[0] == *drinks

получить второй элемент можно тоже двумя способоми
printf("2-й заказ: %i напитка\n", drinks[2]);
printf("2-й заказ: %i напитка\n", *(drinks+2));

индекс, всего лишь число, которое добавляется к указателю
такая хитрая запись
int doses[] = {1,2,3,1000};
doses[3] == *(doses+3) == *(3+doses) == 3[doses]
=======================================
Использование указателя для ввода данных
char name[40];
printf("Введите имя м: ");
прочитать не более 39 символов и знак завершения строки \0
scanf("%39s", name);
// scanf("%19s %19s", first_name, last_name);
в данном случае scanf принимает указатель, ей нужен адресс.
printf("Имя: %s\n", name);

scanf ввод чисел:
int age;
printf("Введите ваш возраст: ");
scanf("%i", &age); используем оператор &

** если забыть ограничивать дляину строки в scanf, программа может завершиться аварийно
------------------------------------------
fgets() - алтернатива scanf
char food[50]; 
printf("Введите любимую еду: ");
fgets(food, sizeof(food), stdin);
- сначала она принимает указатель на буфер food 
- затем принимает максимальный размер строки, влючая \0(но можно явно указать длину)
- данные приходят с клавиатурыstdin 
------------------------------------
Строковый литерал никогда не может быть изменён
char *cards = "JQK"; эта переменная не может изменить данную строку
но если создать массив из строкового литерала, то можно изменить его
char cards[] = "JQK";
строковые литералы, хранятся в памяти, предназначенной только для чтения
cards[] находится в области памяти, которую можно менять, когда она внутри функции, обьявлена и инициализированна
но если cards[] является параметром функции, то она является указателем на строку и может быть изменена
void stack_deck(char cards[])..
то же
void stack_deck(char *cards)..

* если очень надо обьяввить строковый литерал, нучно использовать const
тогда ошибка компеляции будет более пончтной
const char *cards = "AS";