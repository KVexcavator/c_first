На языке C можно писать в функциональном стиле, но сам язык изначально не был спроектирован для этого. В C больше поддерживаются традиционные процедурные подходы, такие как работа с изменяемыми данными, указателями и глобальными переменными. Однако, при соблюдении некоторых правил, можно писать код в функциональном стиле. Вот как это может быть реализовано:

### 1. **Чистые функции**
Функции в C могут быть написаны так, чтобы они не имели побочных эффектов (не изменяли глобальные переменные или состояние программы), что является одним из основ функционального стиля.

Пример чистой функции:
```c
#include <stdio.h>

// Чистая функция, которая не изменяет внешнее состояние, а просто возвращает результат
int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(3, 4);  // Вызов функции
    printf("Result: %d\n", result);  // Вывод результата
    return 0;
}
```

### 2. **Иммутабельность (неизменяемость)**
В C переменные могут изменяться, что противоречит идеям функционального программирования. Однако вы можете написать код так, чтобы не изменять данные, а вместо этого создавать новые значения.

Пример использования неизменяемых данных:
```c
#include <stdio.h>

// Функция возвращает новый массив, не изменяя исходный
void increment_array(const int input[], int output[], int size) {
    for (int i = 0; i < size; i++) {
        output[i] = input[i] + 1;
    }
}

int main() {
    int original[] = {1, 2, 3};
    int updated[3];

    increment_array(original, updated, 3);  // Не изменяем исходный массив, создаем новый

    for (int i = 0; i < 3; i++) {
        printf("%d ", updated[i]);
    }
    return 0;
}
```

### 3. **Функции высшего порядка**
Функции высшего порядка — это функции, которые могут принимать другие функции в качестве аргументов или возвращать их. В C нет встроенной поддержки таких возможностей, как, например, в языках вроде Haskell или JavaScript, но можно использовать указатели на функции.

Пример функции высшего порядка:
```c
#include <stdio.h>

// Функция высшего порядка, которая принимает указатель на другую функцию
int apply_operation(int a, int b, int (*operation)(int, int)) {
    return operation(a, b);
}

int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    printf("Sum: %d\n", apply_operation(3, 4, add));         // Передаем функцию add
    printf("Product: %d\n", apply_operation(3, 4, multiply)); // Передаем функцию multiply
    return 0;
}
```

### 4. **Рекурсия**
Функциональное программирование часто использует рекурсию вместо циклов. В C рекурсия возможна, но из-за отсутствия оптимизации хвостовой рекурсии (tail call optimization) она может быть менее эффективной, чем в языках, ориентированных на функциональный стиль.

Пример рекурсивной функции:
```c
#include <stdio.h>

// Рекурсивная функция для вычисления факториала
int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

int main() {
    printf("Factorial of 5: %d\n", factorial(5));
    return 0;
}
```

### Ограничения C для функционального стиля:
1. **Изменяемость данных**. C работает с указателями и изменяемыми данными, что противоречит концепции неизменяемости в функциональном программировании.
2. **Отсутствие встроенной поддержки функций высшего порядка**. C поддерживает указатели на функции, но это гораздо менее гибко, чем в функциональных языках.
3. **Рекурсия**. Хотя рекурсия поддерживается, в C нет оптимизации хвостовой рекурсии, поэтому глубокие рекурсии могут привести к переполнению стека.
4. **Отсутствие поддержки функциональных конструкций**. В C нет таких мощных функциональных инструментов, как лямбда-функции, композиция функций и другие элементы, присутствующие в языках, ориентированных на функциональное программирование.

### Заключение
Хотя C не является функциональным языком и не предоставляет всех возможностей для написания функционального кода, основные элементы функционального стиля можно реализовать: чистые функции, рекурсия и даже функции высшего порядка. Но из-за отсутствия встроенных возможностей и поддержки неизменяемости данных, писать функциональный код на C менее удобно, чем в языках, специально созданных для этого (например, Haskell или F#).